<?xml version="1.0" encoding="UTF-8"?><sqlb_project><db path="C:/Users/xiaom/OneDrive/Documents/School/ECs/Dataquest/stores.db" readonly="0" foreign_keys="1" case_sensitive_like="0" temp_store="0" wal_autocheckpoint="1000" synchronous="2"/><attached/><window><main_tabs open="structure browser pragmas query" current="3"/></window><tab_structure><column_width id="0" width="300"/><column_width id="1" width="0"/><column_width id="2" width="150"/><column_width id="3" width="3785"/><column_width id="4" width="0"/><expanded_item id="0" parent="1"/><expanded_item id="1" parent="1"/><expanded_item id="2" parent="1"/><expanded_item id="3" parent="1"/></tab_structure><tab_browse><current_table name="4,9:maincustomers"/><default_encoding codec=""/><browse_table_settings><table schema="main" name="customers" show_row_id="0" encoding="" plot_x_axis="" unlock_view_pk="_rowid_"><sort/><column_widths><column index="1" value="187"/><column index="2" value="300"/><column index="3" value="186"/><column index="4" value="190"/><column index="5" value="184"/><column index="6" value="289"/><column index="7" value="224"/><column index="8" value="175"/><column index="9" value="120"/><column index="10" value="123"/><column index="11" value="123"/><column index="12" value="281"/><column index="13" value="121"/></column_widths><filter_values/><conditional_formats/><row_id_formats/><display_formats/><hidden_columns/><plot_y_axes/><global_filter/></table></browse_table_settings></tab_browse><tab_sql><sql name="README">/*



Store X is a struggling small business that has been hit hard by supply chain delays and 

inventory management issues. As such, many popular products are frequently under-stocked,

turning away customers that otherwise would have spent more. As such, the goal of this

data analysis project is to use SQL to determine which products are highest-performing

(sell the most) yet are constantly in low stock, who the highest- and lowest-spending

customers are, and the average profit that each customer brings in during their lifetime

that can be re-spent and invested into the store.



As it turns out, the Classic Cars product line make up the majority of the top 10 most 

in-demand and low-stock products in Store X, meaning they should be re-stocked most often

to optimize inventory needs. The highest- and lowest-spending customers tend to vary with

no clear pattern, and the average customer brings in $39,039.59 over their lifetime in 

Store X. These findings may be used to help Store X determine how it can better optimize

its inventory and wisely calculate how its available funds can attract new customers.



*/</sql><sql name="Table Overview">-- familiarizing with the database: each table's name, number of columns (attributes), and number of rows



SELECT 'Customers' AS table_name,

	   '13' AS number_of_attributes,

	   COUNT(*) AS number_of_rows

  FROM customers



UNION ALL



SELECT 'Products' AS table_name,

	   '9' AS number_of_attributes,

	   COUNT(*) AS number_of_rows

  FROM products

  

UNION ALL



SELECT 'ProductLines' AS table_name,

	   '4' AS number_of_attributes,

	   COUNT(*) AS number_of_rows

  FROM productlines

  

UNION ALL



SELECT 'Orders' AS table_name,

	   '7' AS number_of_attributes,

	   COUNT(*) AS number_of_rows

  FROM orders

  

UNION ALL



SELECT 'OrderDetails' AS table_name,

	   '5' AS number_of_attributes,

	   COUNT(*) AS number_of_rows

  FROM orderdetails

  

UNION ALL



SELECT 'Payments' AS table_name,

	   '4' AS number_of_attributes,

	   COUNT(*) AS number_of_rows

  FROM payments

  

UNION ALL



SELECT 'Employees' AS table_name,

	   '8' AS number_of_attributes,

	   COUNT(*) AS number_of_rows

  FROM employees

  

UNION ALL



SELECT 'Offices' AS table_name,

	   '9' AS number_of_attributes,

	   COUNT(*) AS number_of_rows

  FROM offices;</sql><sql name="Product Optimization Analysis">/* determining which items are low stock and high performance; 

combining the two with a CTS query to find which items should 

be kept constantly restocked, helping the store optimize inventory 



As shown, the Classic Cars product line make up the majority of the top 10 

most in-demand and low-stock products in this store. As such, they should 

be re-stocked most often to optimize inventory needs.

*/



WITH

product_performance_table AS (

	SELECT productCode, SUM(quantityOrdered * priceEach) AS product_performance

	  FROM orderdetails

	 GROUP BY productCode

	 ORDER BY product_performance DESC

	 LIMIT 10

)



SELECT productCode AS priority_product_codes, productLine, productName,

	   ROUND((SELECT SUM(quantityOrdered) * 1.0

			    FROM orderdetails AS od

			   WHERE od.productCode = p.productCode) 

			 / quantityInStock, 2) AS low_stock

  FROM products AS p

 WHERE productCode IN (SELECT productCode

					     FROM product_performance_table)

 GROUP BY productCode

 ORDER BY low_stock DESC

 LIMIT 10;

 

 /* 

low_stock code:

SELECT productCode,

	   ROUND((SELECT SUM(quantityOrdered) * 1.0

			    FROM orderdetails AS od

			   WHERE od.productCode = p.productCode	

			 ) / quantityInStock, 2) AS low_stock

  FROM products AS p

 GROUP BY productCode

 ORDER BY low_stock DESC

 LIMIT 10;



product performance code:

SELECT productCode, SUM(quantityOrdered * priceEach) AS product_performance

  FROM orderdetails

 GROUP BY productCode

 ORDER BY product_performance DESC

 LIMIT 10;

 */</sql><sql name="Customer Spending Analysis">/* determining which customers spend the most and which spend the least to help

influence potential marketing campaigns, ex. how to retain the loyalest customers */



WITH

customer_profits AS (

SELECT o.customerNumber, SUM(od.quantityOrdered * (od.priceEach - p.buyPrice)) AS profit

  FROM orders AS o

  JOIN orderdetails AS od

    ON o.orderNumber = od.orderNumber

  JOIN products AS p

    ON od.productCode = p.productCode

 GROUP BY o.customerNumber

)



-- the 5 highest-spending customers

SELECT c.contactLastName, c.contactFirstName, c.city, c.country, customer_profits.profit

  FROM customers AS c

  JOIN customer_profits

    ON customer_profits.customerNumber = c.customerNumber

 ORDER BY customer_profits.profit DESC

 LIMIT 5

 

-- the 5 lowest-spending customers (uncomment code)

/*

SELECT c.contactLastName, c.contactFirstName, c.city, c.country, customer_profits.profit

  FROM customers AS c

  JOIN customer_profits

    ON customer_profits.customerNumber = c.customerNumber

 ORDER BY customer_profits.profit

 LIMIT 5

*/

  </sql><sql name="Average Customer Profits">-- determining how much the store can spend attracting new customers



WITH

customer_profits AS (

SELECT o.customerNumber, SUM(od.quantityOrdered * (od.priceEach - p.buyPrice)) AS profit

  FROM orders AS o

  JOIN orderdetails AS od

    ON o.orderNumber = od.orderNumber

  JOIN products AS p

    ON od.productCode = p.productCode

 GROUP BY o.customerNumber

)



SELECT AVG(customer_profits.profit) AS average_customer_profits

  FROM customer_profits

  

/* 

-- determining number of new customers each month with code from Dataquest

WITH 

payment_with_year_month_table AS (

SELECT *, 

       CAST(SUBSTR(paymentDate, 1,4) AS INTEGER)*100 + CAST(SUBSTR(paymentDate, 6,7) AS INTEGER) AS year_month

  FROM payments p

),



customers_by_month_table AS (

SELECT p1.year_month, COUNT(*) AS number_of_customers, SUM(p1.amount) AS total

  FROM payment_with_year_month_table p1

 GROUP BY p1.year_month

),



new_customers_by_month_table AS (

SELECT p1.year_month, 

       COUNT(*) AS number_of_new_customers,

       SUM(p1.amount) AS new_customer_total,

       (SELECT number_of_customers

          FROM customers_by_month_table c

        WHERE c.year_month = p1.year_month) AS number_of_customers,

       (SELECT total

          FROM customers_by_month_table c

         WHERE c.year_month = p1.year_month) AS total

  FROM payment_with_year_month_table p1

 WHERE p1.customerNumber NOT IN (SELECT customerNumber

                                   FROM payment_with_year_month_table p2

                                  WHERE p2.year_month &lt; p1.year_month)

 GROUP BY p1.year_month

)



SELECT year_month, 

       ROUND(number_of_new_customers*100/number_of_customers,1) AS number_of_new_customers_props,

       ROUND(new_customer_total*100/total,1) AS new_customers_total_props

  FROM new_customers_by_month_table

*/</sql><current_tab id="0"/></tab_sql></sqlb_project>
